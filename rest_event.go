package main

import (
	"fmt"
	"github.com/labstack/echo"
	"gopkg.in/mgutz/dat.v1"
	"log"
	"net/http"
	"strconv"
)

///////////////////////////////////////////////////////////////////////
//       Generated By codegen from SQL table event
//        Event REST Functions

type DBevent struct {
	ID           int          `db:"id"`
	SiteId       int          `db:"site_id"`
	Type         string       `db:"type"`
	RefId        int          `db:"ref_id"`
	Priority     int          `db:"priority"`
	StartDate    dat.NullTime `db:"startdate"`
	ParentEvent  int          `db:"parent_event"`
	CreatedBy    int          `db:"created_by"`
	AllocatedBy  int          `db:"allocated_by"`
	AllocatedTo  int          `db:"allocated_to"`
	Completed    dat.NullTime `db:"completed"`
	LabourCost   float64      `db:"labour_cost"`
	MaterialCost float64      `db:"material_cost"`
	OtherCost    float64      `db:"other_cost"`
	Notes        string       `db:"notes"`
	Status       string       `db:"status"`
}

type DBeventResponse struct {
	ID              int     `db:"id"`
	SiteId          int     `db:"site_id"`
	Type            string  `db:"type"`
	RefId           int     `db:"ref_id"`
	MachineName     string  `db:"machine_name"`
	SiteName        string  `db:"site_name"`
	Priority        int     `db:"priority"`
	StartDate       string  `db:"startdate"`
	ParentEvent     int     `db:"parent_event"`
	CreatedBy       int     `db:"created_by"`
	Username        string  `db:"username"`
	AllocatedBy     int     `db:"allocated_by"`
	AllocatedByUser *string `db:"allocated_by_user"`
	AllocatedTo     int     `db:"allocated_to"`
	AllocatedToUser *string `db:"allocated_to_user"`
	Completed       string  `db:"completed"`
	LabourCost      string  `db:"labour_cost"`
	MaterialCost    string  `db:"material_cost"`
	OtherCost       string  `db:"other_cost"`
	Notes           string  `db:"notes"`
	Status          string  `db:"status"`
}

type MachineEventRequest struct {
	Machine string `json:"machine"`
	Descr   string `json:"descr"`
	Action  string `json:"action"`
}

type ToolEventRequest struct {
	Tool   string `json:"tool"`
	Descr  string `json:"descr"`
	Action string `json:"action"`
}

func queryMachineEvents(c *echo.Context) error {

	_, err := securityCheck(c, "readEvent")
	if err != nil {
		return c.String(http.StatusUnauthorized, err.Error())
	}

	id := getID(c)
	var record []*DBeventResponse
	err = DB.SQL(`select e.id,e.parent_event,
		e.site_id,e.type,e.ref_id,e.notes,
		to_char(e.startdate,'DD Mon YYYY HH24:MI:SS pm') as startdate,
		e.labour_cost, e.material_cost,e.other_cost,
		u1.username as username, 
		u2.username as allocated_by_user, 
		u3.username as allocated_to_user,
		m.name as machine_name,
		s.name as site_name		
		from event e
		left join users u1 on (u1.id=e.created_by) 
		left join users u2 on (u2.id=e.allocated_by) 
		left join users u3 on (u3.id=e.allocated_to) 
		left join machine m on (m.id=e.ref_id)
		left join site s on (s.id=m.site_id)
		where e.type like 'Machine%'
		and e.ref_id=$1
		order by e.startdate desc`, id).QueryStructs(&record)

	log.Println("Completed machine event query", len(record))

	if err != nil {
		return c.String(http.StatusNoContent, err.Error())
	}
	return c.JSON(http.StatusOK, record)
}

func queryEvents(c *echo.Context) error {

	claim, err := securityCheck(c, "readEvent")
	if err != nil {
		return c.String(http.StatusUnauthorized, err.Error())
	}

	sites := getClaimedSites(claim)
	log.Println(sites)
	var record []*DBeventResponse
	err = DB.SQL(`select e.id,e.parent_event,
		e.site_id,e.type,e.ref_id,e.notes,
		to_char(e.startdate,'DD Mon YY HH24:MI') as startdate,
		e.labour_cost, e.material_cost,e.other_cost,
		u1.username as username, 
		u2.username as allocated_by_user, 
		u3.username as allocated_to_user,
		m.name as machine_name,
		s.name as site_name
		from event e
		left join users u1 on (u1.id=e.created_by) 
		left join users u2 on (u2.id=e.allocated_by) 
		left join users u3 on (u3.id=e.allocated_to) 
		left join machine m on (m.id=e.ref_id)
		left join site s on (s.id=m.site_id)
		where e.type like 'Machine%'
		and e.site_id in $1
		order by e.startdate desc`, sites).QueryStructs(&record)

	if err != nil {
		return c.String(http.StatusNoContent, err.Error())
	}

	return c.JSON(http.StatusOK, record)
}

func getEvent(c *echo.Context) error {

	_, err := securityCheck(c, "readEvent")
	if err != nil {
		return c.String(http.StatusUnauthorized, err.Error())
	}

	id := getID(c)
	var record DBeventResponse
	err = DB.SQL(`select e.id,e.parent_event,
		e.site_id,e.type,e.ref_id,e.notes,
		to_char(e.startdate,'DD Mon YYYY HH24:MI:SS') as startdate,
		e.labour_cost, e.material_cost,e.other_cost,
		e.created_by as created_by,
		e.allocated_by as allocated_by,
		e.allocated_to as allocated_to,
		u1.username as username, 
		u2.username as allocated_by_user, 
		u3.username as allocated_to_user 
		from event e
		left join users u1 on (u1.id=e.created_by) 
		left join users u2 on (u2.id=e.allocated_by) 
		left join users u3 on (u3.id=e.allocated_to) 
		where e.id=$1`, id).QueryStruct(&record)

	if err != nil {
		return c.String(http.StatusNoContent, err.Error())
	}

	return c.JSON(http.StatusOK, record)
}

type EventUpdate struct {
	Notes string `db:"notes"`
}

// All this saves is the notes field
func saveEvent(c *echo.Context) error {

	_, err := securityCheck(c, "writeEvent")
	if err != nil {
		return c.String(http.StatusUnauthorized, err.Error())
	}

	id := getID(c)

	record := &EventUpdate{}
	if err = c.Bind(record); err != nil {
		return c.String(http.StatusBadRequest, err.Error())
	}

	_, err = DB.Update("event").
		SetWhitelist(record, "notes").
		Where("id = $1", id).
		Exec()

	if err != nil {
		return c.String(http.StatusNotModified, err.Error())
	}

	return c.JSON(http.StatusOK, id)
}

func queryToolEvents(c *echo.Context) error {

	_, err := securityCheck(c, "readEvent")
	if err != nil {
		return c.String(http.StatusUnauthorized, err.Error())
	}

	id := getID(c)
	var record []*DBeventResponse
	err = DB.SQL(`select e.id,
		e.site_id,e.type,e.ref_id,e.notes,
		to_char(e.startdate,'DD Mon YYYY HH24:MI:SS pm') as startdate,
		e.labour_cost, e.material_cost,e.other_cost,
		u1.username as username, 
		u2.username as allocated_by_user, 
		u3.username as allocated_to_user 
		from event e
		left join users u1 on (u1.id=e.created_by) 
		left join users u2 on (u2.id=e.allocated_by) 
		left join users u3 on (u3.id=e.allocated_to) 
		where e.type like 'Tool%'
		and e.ref_id=$1
		order by e.startdate desc`, id).QueryStructs(&record)

	log.Println("Completed tool event query", len(record))

	if err != nil {
		return c.String(http.StatusNoContent, err.Error())
	}
	return c.JSON(http.StatusOK, record)
}

func raiseEventMachine(c *echo.Context) error {

	claim, err := securityCheck(c, "writeEvent")
	if err != nil {
		return c.String(http.StatusUnauthorized, err.Error())
	}

	req := &MachineEventRequest{}
	err = c.Bind(req)
	if err != nil {
		log.Println("Binding:", err.Error())
		return c.String(http.StatusBadRequest, err.Error())
	}

	log.Println("Request:", req)

	// Lookup the machine
	var siteId int
	var machineId int
	machineId, err = strconv.Atoi(req.Machine)
	if err != nil {
		return c.String(http.StatusBadRequest, fmt.Sprintf("Invalid Machine ID %s", req.Machine))
	}

	err = DB.SQL(`select site_id from machine where id=$1`, machineId).QueryScalar(&siteId)
	if err != nil {
		return c.String(http.StatusBadRequest, fmt.Sprintf("Invalid Site ID for Machine %d: %s", machineId, err.Error()))
	}

	UID, Username := getClaimedUser(claim)

	// Create the event record
	evt := &DBevent{
		SiteId:    siteId,
		Type:      fmt.Sprintf("Machine: %s", req.Action),
		RefId:     machineId,
		Priority:  1,
		CreatedBy: UID,
		Notes:     req.Descr,
	}
	DB.InsertInto("event").
		Whitelist("site_id", "type", "ref_id", "priority", "created_by", "notes").
		Record(evt).
		Returning("id").
		QueryScalar(&evt.ID)

	// Update the machine record
	switch req.Action {
	case "Alert":
		_, err = DB.SQL(`update machine 
			set alert_at=localtimestamp, status=$2 
			where id=$1`,
			machineId,
			`Needs Attention`).
			Exec()
	case "Halt":
		_, err = DB.SQL(`update machine 
			set stopped_at=localtimestamp, status=$2, is_running=false
			where id=$1`,
			machineId,
			`Stopped`).
			Exec()
	}

	if err != nil {
		return c.String(http.StatusInternalServerError, err.Error())
	}

	log.Println("Raising Event", evt.ID, evt, "User:", Username)
	publishSocket("machine", machineId)
	publishSocket("event", evt.ID)
	return c.String(http.StatusOK, "Event Raised on the Machine")

	// TODO - add a mega amount of auditing to the machine and event records
}

func raiseEventTool(c *echo.Context) error {

	claim, err := securityCheck(c, "writeEvent")
	if err != nil {
		return c.String(http.StatusUnauthorized, err.Error())
	}

	req := &ToolEventRequest{}
	err = c.Bind(req)
	if err != nil {
		log.Println("Binding:", err.Error())
		return c.String(http.StatusBadRequest, err.Error())
	}

	log.Println("Request:", req)

	// Lookup the machine
	var siteId int
	var machineId int
	var toolId int
	var toolName string
	toolId, err = strconv.Atoi(req.Tool)
	if err != nil {
		return c.String(http.StatusBadRequest, fmt.Sprintf("Invalid Tool ID %s", req.Tool))
	}

	err = DB.SQL(`
		select 
		site_id,machine_id,name 
		from component 
		where id=$1`, toolId).
		QueryScalar(&siteId, &machineId, &toolName)
	if err != nil {
		return c.String(http.StatusBadRequest, fmt.Sprintf("Invalid Site ID for Tool (%d): %s", toolId, err.Error()))
	}

	UID, Username := getClaimedUser(claim)

	// Create 2 event records - one for the tool, and one for the machine (with the tool event as the parent)
	evt := &DBevent{
		SiteId:    siteId,
		Type:      fmt.Sprintf("Tool: %s", req.Action),
		RefId:     toolId,
		Priority:  1,
		CreatedBy: UID,
		Notes:     req.Descr,
	}
	DB.InsertInto("event").
		Whitelist("site_id", "type", "ref_id", "priority", "created_by", "notes").
		Record(evt).
		Returning("id").
		QueryScalar(&evt.ID)

	evt.RefId = machineId
	evt.Type = fmt.Sprintf("Machine: %s", req.Action)
	evt.Notes = fmt.Sprintf("%s on Tool %s", req.Action, toolName)
	evt.ParentEvent = evt.ID
	DB.InsertInto("event").
		Whitelist("site_id", "type", "ref_id", "priority", "created_by", "notes", "parent_event").
		Record(evt).
		Returning("id").
		QueryScalar(&evt.ID)

	// Update the machine record and the tool record
	switch req.Action {
	case "Alert":
		_, err = DB.SQL(`update machine 
			set alert_at=localtimestamp, status=$2 
			where id=$1`,
			machineId,
			`Needs Attention`).
			Exec()

		_, err = DB.SQL(`update component
			set status='Needs Attention'
			where id=$1`, toolId).
			Exec()
	case "Halt":
		_, err = DB.SQL(`update machine 
			set stopped_at=localtimestamp, status=$2, is_running=false
			where id=$1`,
			machineId,
			`Stopped`).
			Exec()
		_, err = DB.SQL(`update component
			set status='Stopped', is_running=false
			where id=$1`, toolId).
			Exec()
	case "Clear":
		_, err = DB.SQL(`update machine 
			set started_at=localtimestamp, status=$2, is_running=true
			where id=$1`,
			machineId,
			`Running`).
			Exec()
		_, err = DB.SQL(`update component
			set status='Running', is_running=true
			where machine_id=$1`, machineId).
			Exec()
	}

	if err != nil {
		return c.String(http.StatusInternalServerError, err.Error())
	}

	log.Println("Raising Tool Event", evt.ID, evt, "User:", Username)
	publishSocket("machine", machineId)
	publishSocket("tool", toolId)
	publishSocket("event", evt.ID)

	// TODO - audit records for both the machine and tool

	return c.String(http.StatusOK, "Event Raised on the Tool & Machine")
}
